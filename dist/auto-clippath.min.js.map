{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export interface Size2D {\n  width: number;\n  height: number;\n}\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport default async function autoClipPath(\n  image: HTMLImageElement,\n  imageSize: Size2D,\n  options?: {\n    shift?: Coordinates;\n    gap?: number;\n    distance?: number;\n  },\n): Promise<{ clipPath: Coordinates[]; time: number }> {\n  const { width, height } = imageSize;\n\n  const shift =\n    options && \"shift\" in options && options.shift !== undefined\n      ? options.shift\n      : { x: 0, y: 0 };\n  const gap =\n    options && \"gap\" in options && options.gap !== undefined ? options.gap : 0;\n  const distance =\n    options && \"distance\" in options && options.distance !== undefined\n      ? options.distance\n      : Infinity;\n\n  const t = performance.now();\n\n  const canvas = new OffscreenCanvas(width, height);\n  const ctx = canvas.getContext(\"2d\")!;\n\n  try {\n    ctx.drawImage(\n      image,\n      -shift.x,\n      -shift.y,\n      width,\n      height,\n      0,\n      0,\n      width,\n      height,\n    );\n\n    return new Promise((resolve) => {\n      resolve({\n        clipPath: generateClipPathForNonTransparentEdges(\n          ctx.getImageData(0, 0, width, height),\n          gap,\n          distance,\n        ),\n        time: performance.now() - t,\n      });\n    });\n  } catch (e) {\n    throw new Error(e);\n  }\n}\n\nfunction generateConvexHull(points: Coordinates[]): Coordinates[] {\n  if (points.length <= 3) {\n    return points;\n  }\n\n  const getOrientation = (\n    p: Coordinates,\n    q: Coordinates,\n    r: Coordinates,\n  ): number => {\n    const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\n    if (val === 0) return 0;\n\n    return val > 0 ? 1 : 2;\n  };\n\n  const sortByPolarAngle = (a: Coordinates, b: Coordinates): number => {\n    const orientation = getOrientation(points[0], a, b);\n\n    if (orientation === 0) {\n      return (\n        Math.hypot(a.x - points[0].x, a.y - points[0].y) -\n        Math.hypot(b.x - points[0].x, b.y - points[0].y)\n      );\n    }\n\n    return orientation === 2 ? -1 : 1;\n  };\n\n  points.sort(sortByPolarAngle);\n\n  const stack: Coordinates[] = [];\n  stack.push(points[0]);\n\n  for (let i = 2; i < points.length; i++) {\n    let top = stack.length - 1;\n\n    while (\n      top >= 1 &&\n      getOrientation(stack[top - 1], stack[top], points[i]) !== 2\n    ) {\n      stack.pop();\n      top = stack.length - 1;\n    }\n\n    stack.push(points[i]);\n  }\n\n  return stack;\n}\n\nfunction crossProduct(\n  p1: Coordinates,\n  p2: Coordinates,\n  p3: Coordinates,\n): number {\n  return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\nfunction distance(p1: Coordinates, p2: Coordinates): number {\n  return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n}\n\nfunction expandConvexHull(\n  convexHull: Coordinates[],\n  gap: number,\n  minDistanceBetweenPoints: number,\n): Coordinates[] {\n  const expandedHull: Coordinates[] = [];\n\n  function addPointToHull(point: Coordinates) {\n    if (\n      expandedHull.length === 0 ||\n      distance(point, expandedHull[expandedHull.length - 1]) >\n        minDistanceBetweenPoints\n    ) {\n      expandedHull.push({\n        x: Math.round(point.x),\n        y: Math.round(point.y),\n      });\n    }\n  }\n\n  for (let i = 0; i < convexHull.length; i++) {\n    const currentPoint = convexHull[i];\n    const nextPoint = convexHull[(i + 1) % convexHull.length];\n\n    const dx = nextPoint.x - currentPoint.x;\n    const dy = nextPoint.y - currentPoint.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const unitX = dx / length;\n    const unitY = dy / length;\n\n    const expandedCurrentPoint: Coordinates = {\n      x: currentPoint.x + unitY * gap,\n      y: currentPoint.y - unitX * gap,\n    };\n    const expandedNextPoint: Coordinates = {\n      x: nextPoint.x + unitY * gap,\n      y: nextPoint.y - unitX * gap,\n    };\n\n    addPointToHull(expandedCurrentPoint);\n\n    let j = expandedHull.length;\n    while (\n      j >= 2 &&\n      crossProduct(\n        expandedHull[j - 2],\n        expandedHull[j - 1],\n        expandedNextPoint,\n      ) <= 0\n    ) {\n      expandedHull.pop();\n      j--;\n    }\n\n    if (i !== convexHull.length - 1) addPointToHull(expandedNextPoint);\n  }\n\n  return expandedHull;\n}\n\nfunction generateClipPathForNonTransparentEdges(\n  imageData: ImageData,\n  gap: number,\n  minDistanceBetweenPoints: number,\n): Coordinates[] {\n  const { width, height, data } = imageData;\n\n  const isOpaque = (x: number, y: number): boolean => {\n    const alpha = data[(y * width + x) * 4 + 3];\n\n    return alpha > 1;\n  };\n\n  const edgePoints: Coordinates[] = [];\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      if (isOpaque(x, y)) {\n        edgePoints.push({ x, y });\n      }\n    }\n  }\n\n  const convexHull = generateConvexHull(edgePoints);\n\n  return expandConvexHull(convexHull, gap, minDistanceBetweenPoints);\n}\n"],
  "mappings": "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",
  "names": ["autoClipPath", "image", "imageSize", "options", "width", "height", "shift", "gap", "distance", "t", "ctx", "resolve", "generateClipPathForNonTransparentEdges", "e", "generateConvexHull", "points", "getOrientation", "p", "q", "r", "val", "sortByPolarAngle", "a", "b", "orientation", "stack", "i", "top", "crossProduct", "p1", "p2", "p3", "expandConvexHull", "convexHull", "minDistanceBetweenPoints", "expandedHull", "addPointToHull", "point", "currentPoint", "nextPoint", "dx", "dy", "length", "unitX", "unitY", "expandedCurrentPoint", "expandedNextPoint", "j", "imageData", "data", "isOpaque", "x", "y", "edgePoints"]
}
